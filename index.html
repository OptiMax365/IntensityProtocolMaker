<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>INTENSITY PROTOCOL — Pilot Dictionary (Tabs)</title>
<style>
  body {
    margin: 0;
    font-family: system-ui, sans-serif;
    background: #05060a;
    color: #f5f5f5;
    display: flex;
    height: 100vh;
  }
  .sidebar {
    width: 260px;
    background: #0b0d14;
    border-right: 1px solid #222633;
    padding: 16px;
    box-sizing: border-box;
    display: flex;
    flex-direction: column;
    gap: 12px;
  }
  .sidebar h1 {
    font-size: 18px;
    margin: 0 0 4px;
    letter-spacing: 0.06em;
    text-transform: uppercase;
    color: #9ca3ff;
  }
  .sidebar small {
    color: #9ca3af;
  }
  .search-box input {
    width: 100%;
    padding: 8px;
    border-radius: 6px;
    border: 1px solid #374151;
    background: #020617;
    color: #e5e7eb;
  }
  .word-list {
    flex: 1;
    overflow-y: auto;
    margin-top: 8px;
    border-radius: 6px;
    border: 1px solid #111827;
    background: #020617;
    padding: 4px;
    font-size: 13px;
  }
  .word-item {
    padding: 6px 8px;
    border-radius: 4px;
    cursor: pointer;
  }
  .word-item:hover {
    background: #111827;
  }
  .word-item.active {
    background: #1d283a;
    color: #c7d2fe;
  }

  .main {
    flex: 1;
    padding: 0;
    display: flex;
    flex-direction: column;
  }

.tabs-bar {
    display: flex;
    flex-direction: row;        /* FORCE HORIZONTAL */
    align-items: center;
    background: #020617;
    border-bottom: 1px solid #111827;
    padding: 4px 8px;
    gap: 4px;
    overflow-x: auto;           /* ENABLE HORIZONTAL SCROLL */
    white-space: nowrap;        /* KEEP TABS ON ONE LINE */
}



#tabsContainer {
    display: flex;
    flex-direction: row;   /* horizontal */
    align-items: center;
    gap: 4px;
    flex-wrap: nowrap;     /* prevents wrapping */
}



  
  .tab {
    padding: 4px 10px;
    border-radius: 6px 6px 0 0;
    background: #111827;
    color: #e5e7eb;
    font-size: 12px;
    cursor: pointer;
    display: flex;
    align-items: center;
    gap: 6px;
  }
  .tab.active {
    background: #1f2937;
    color: #c7d2fe;
  }
  .tab span.close {
    font-size: 11px;
    cursor: pointer;
    color: #9ca3af;
  }
  .tab span.close:hover {
    color: #fca5a5;
  }
  .tab-add {
    padding: 4px 10px;
    border-radius: 6px;
    background: #111827;
    color: #e5e7eb;
    font-size: 14px;
    cursor: pointer;
  }
  .tab-add:hover {
    background: #1f2937;
  }

  .topbar {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 6px 16px;
    border-bottom: 1px solid #111827;
    background: #020617;
    font-size: 13px;
  }
  .topbar-left {
    display: flex;
    gap: 8px;
    align-items: center;
  }
  .topbar button {
    padding: 6px 10px;
    border-radius: 6px;
    border: none;
    background: #4b5563;
    color: #e5e7eb;
    cursor: pointer;
    font-size: 12px;
  }
  .topbar button:hover {
    background: #6b7280;
  }
  .topbar-project {
    font-weight: 500;
    color: #9ca3ff;
  }
  .autosave-indicator {
    font-size: 11px;
    color: #6ee7b7;
    opacity: 0;
    transition: opacity 0.3s ease;
  }
  .autosave-indicator.visible {
    opacity: 1;
  }

  .content {
    flex: 1;
    padding: 16px 20px;
    display: flex;
    flex-direction: column;
  }

  .header {
    display: flex;
    justify-content: space-between;
    align-items: baseline;
    margin-bottom: 12px;
  }
  .header-title {
    font-size: 22px;
    font-weight: 600;
  }
  .badge {
    font-size: 11px;
    padding: 2px 8px;
    border-radius: 999px;
    border: 1px solid #4b5563;
    color: #9ca3ff;
    text-transform: uppercase;
  }

  .scale-row {
    margin-bottom: 10px;
  }
  .scale-label {
    font-size: 12px;
    color: #9ca3af;
    margin-bottom: 4px;
    display: flex;
    justify-content: space-between;
    align-items: center;
  }
  .scale-label-left {
    display: flex;
    gap: 8px;
    align-items: center;
  }
  .scale-add-btn {
    font-size: 10px;
    padding: 2px 6px;
    border-radius: 999px;
    border: none;
    background: #4f46e5;
    color: white;
    cursor: pointer;
  }
  .scale-add-btn:hover {
    background: #4338ca;
  }

  .synonym-chips {
    display: flex;
    flex-wrap: wrap;
    gap: 6px;
  }
  .chip {
    padding: 4px 8px;
    border-radius: 999px;
    font-size: 12px;
    border: 1px solid #374151;
    background: #020617;
    cursor: pointer;
  }
  .chip:hover {
    background: #1f2937;
  }

  .builder-panel {
    margin-top: 20px;
    padding: 12px;
    border: 1px solid #1f2937;
    border-radius: 6px;
    background: #0b0d14;
  }
  .builder-panel h2 {
    margin: 0 0 10px;
    font-size: 16px;
    color: #9ca3ff;
  }
  .builder-panel input, .builder-panel select {
    width: 100%;
    padding: 8px;
    margin-bottom: 8px;
    border-radius: 6px;
    border: 1px solid #374151;
    background: #020617;
    color: #e5e7eb;
  }
  .builder-panel button {
    padding: 8px 12px;
    border-radius: 6px;
    border: none;
    background: #4f46e5;
    color: white;
    cursor: pointer;
    margin-right: 6px;
    margin-top: 4px;
    font-size: 12px;
  }
  .builder-panel button:hover {
    background: #4338ca;
  }

  .export-btn {
    margin-top: 10px;
    background: #16a34a !important;
  }
  .pilot-btn {
    margin-top: 6px;
    background: #f97316 !important;
  }
</style>
</head>

<body>

<!-- SIDEBAR -->
<div class="sidebar">
  <h1>Intensity Protocol</h1>
  <small>Tabs = multiple projects. Pilot builds each one with you.</small>

  <div class="search-box">
    <input id="searchInput" placeholder="Search word…" />
  </div>

  <div class="word-list" id="wordList"></div>

  <button id="pilotBtn" class="pilot-btn">Pilot Add Word</button>
  <button id="exportBtn" class="export-btn">Export Dictionary</button>
  <input type="file" id="importFile" style="margin-top:8px;" />
</div>

<!-- MAIN -->
<div class="main">
  <!-- TABS BAR -->
  <div class="tabs-bar">
    <div id="tabsContainer"></div>
    <div id="addTabBtn" class="tab-add">+</div>
  </div>

  <!-- TOP PROJECT BAR -->
  <div class="topbar">
    <div class="topbar-left">
      <button id="newProjectBtn">New Project</button>
      <button id="loadProjectBtn">Load Project</button>
      <button id="saveAsBtn">Save As…</button>
      <span class="topbar-project" id="projectNameLabel">No project name</span>
    </div>
    <div class="autosave-indicator" id="autosaveIndicator">Autosaved</div>
  </div>

  <div class="content">
    <div class="header">
      <div class="header-title" id="currentWord">Select or Add a Word</div>
      <div class="badge" id="wordCountBadge">0 words</div>
    </div>

    <div style="margin-bottom:8px;">
      <button id="editAllBtn" style="font-size:12px;padding:6px 10px;border-radius:6px;border:none;background:#6b21a8;color:white;cursor:pointer;">
        Edit All Synonyms for This Word
      </button>
    </div>

    <div id="scalesContainer"></div>

    <!-- MANUAL BUILDER (optional tweak) -->
    <div class="builder-panel">
      <h2>Manual Adjust / Edit (Optional)</h2>

      <input id="wordInput" placeholder="Word (e.g., unstoppable)" />
      <input id="semanticInput" placeholder="Semantic field (e.g., power / momentum)" />

      <select id="intensitySelect">
        <option value="mild">Mild</option>
        <option value="medium">Medium</option>
        <option value="strong">Strong</option>
        <option value="extreme">Extreme</option>
      </select>

      <input id="synonymInput" placeholder="Add synonym…" />

      <button id="addSynonymBtn">Add Synonym</button>
      <button id="saveWordBtn">Save Word</button>
    </div>
  </div>
</div>

<script>
/* ------------------------------
   PROJECTS + ACTIVE STATE
--------------------------------*/
let projects = JSON.parse(localStorage.getItem("semanticProjects")) || [];
let activeProjectId = localStorage.getItem("semanticActiveProjectId") || null;

function createEmptyProject(name) {
  return {
    id: "proj_" + Date.now() + "_" + Math.random().toString(16).slice(2),
    name: name || "Untitled",
    dictionary: {}
  };
}

// If no projects, bootstrap from old single dictionary if present
let legacyDict = JSON.parse(localStorage.getItem("semanticDictionary") || "null");
if (projects.length === 0) {
  if (legacyDict && typeof legacyDict === "object") {
    const p = createEmptyProject("Legacy Project");
    p.dictionary = legacyDict;
    projects.push(p);
    activeProjectId = p.id;
  } else {
    const p = createEmptyProject("Project 1");
    projects.push(p);
    activeProjectId = p.id;
  }
}

if (!activeProjectId && projects.length > 0) {
  activeProjectId = projects[0].id;
}

/* ------------------------------
   CURRENT PROJECT HELPERS
--------------------------------*/
function getActiveProject() {
  return projects.find(p => p.id === activeProjectId) || projects[0];
}

function setActiveProject(id) {
  activeProjectId = id;
  localStorage.setItem("semanticActiveProjectId", activeProjectId);
  syncFromProject();
  renderTabs();
}

/* ------------------------------
   SYNC PROJECT <-> UI STATE
--------------------------------*/
let dictionary = {};
let projectName = "";
let currentWord = null;

/* DOM ELEMENTS */
const tabsContainer = document.getElementById("tabsContainer");
const addTabBtn = document.getElementById("addTabBtn");

const wordListEl = document.getElementById("wordList");
const searchInputEl = document.getElementById("searchInput");
const currentWordEl = document.getElementById("currentWord");
const wordCountBadgeEl = document.getElementById("wordCountBadge");
const scalesContainerEl = document.getElementById("scalesContainer");

const wordInput = document.getElementById("wordInput");
const semanticInput = document.getElementById("semanticInput");
const intensitySelect = document.getElementById("intensitySelect");
const synonymInput = document.getElementById("synonymInput");

const addSynonymBtn = document.getElementById("addSynonymBtn");
const saveWordBtn = document.getElementById("saveWordBtn");
const exportBtn = document.getElementById("exportBtn");
const importFile = document.getElementById("importFile");
const pilotBtn = document.getElementById("pilotBtn");
const editAllBtn = document.getElementById("editAllBtn");

const newProjectBtn = document.getElementById("newProjectBtn");
const loadProjectBtn = document.getElementById("loadProjectBtn");
const saveAsBtn = document.getElementById("saveAsBtn");
const projectNameLabel = document.getElementById("projectNameLabel");
const autosaveIndicator = document.getElementById("autosaveIndicator");

/* AUTOSAVE INDICATOR */
let autosaveTimeout = null;
function showAutosaveIndicator() {
  autosaveIndicator.classList.add("visible");
  if (autosaveTimeout) clearTimeout(autosaveTimeout);
  autosaveTimeout = setTimeout(() => {
    autosaveIndicator.classList.remove("visible");
  }, 1200);
}

/* SAVE ALL PROJECTS */
function saveProjects() {
  localStorage.setItem("semanticProjects", JSON.stringify(projects));
  localStorage.setItem("semanticActiveProjectId", activeProjectId);
  showAutosaveIndicator();
}

/* SYNC FROM ACTIVE PROJECT INTO UI STATE */
function syncFromProject() {
  const proj = getActiveProject();
  if (!proj) return;
  dictionary = proj.dictionary || {};
  projectName = proj.name || "Untitled";
  currentWord = null;
  currentWordEl.textContent = "Select or Add a Word";
  scalesContainerEl.innerHTML = "";
  wordInput.value = "";
  semanticInput.value = "";
  updateProjectNameLabel();
  renderWordList(searchInputEl.value);
}

/* SYNC FROM UI STATE BACK INTO ACTIVE PROJECT */
function syncToProject() {
  const proj = getActiveProject();
  if (!proj) return;
  proj.dictionary = dictionary;
  proj.name = projectName || proj.name;
  saveProjects();
}

/* PROJECT NAME LABEL */
function updateProjectNameLabel() {
  projectNameLabel.textContent = projectName ? "Project: " + projectName : "No project name";
}

/* RENDER TABS */
function renderTabs() {
  tabsContainer.innerHTML = "";
  projects.forEach(p => {
    const tab = document.createElement("div");
    tab.className = "tab" + (p.id === activeProjectId ? " active" : "");
    tab.onclick = () => {
      if (p.id !== activeProjectId) {
        setActiveProject(p.id);
      }
    };
    const titleSpan = document.createElement("span");
    titleSpan.textContent = p.name || "Untitled";
    tab.appendChild(titleSpan);

    if (projects.length > 1) {
      const closeSpan = document.createElement("span");
      closeSpan.className = "close";
      closeSpan.textContent = "×";
      closeSpan.onclick = (e) => {
        e.stopPropagation();
        closeProjectTab(p.id);
      };
      tab.appendChild(closeSpan);
    }

    tabsContainer.appendChild(tab);
  });
}

/* CLOSE TAB / PROJECT */
function closeProjectTab(id) {
  const idx = projects.findIndex(p => p.id === id);
  if (idx === -1) return;
  const ok = confirm("Close this project tab? It will remain in localStorage/exported files if you saved it.");
  if (!ok) return;
  projects.splice(idx, 1);
  if (projects.length === 0) {
    const p = createEmptyProject("Project 1");
    projects.push(p);
    activeProjectId = p.id;
  } else {
    if (activeProjectId === id) {
      activeProjectId = projects[Math.max(0, idx - 1)].id;
    }
  }
  saveProjects();
  setActiveProject(activeProjectId);
}

/* ADD TAB BUTTON */
addTabBtn.onclick = () => {
  const name = prompt("New project name:", "New Project");
  const p = createEmptyProject(name || "New Project");
  projects.push(p);
  activeProjectId = p.id;
  saveProjects();
  setActiveProject(activeProjectId);
};

/* RENDER WORD LIST */
function renderWordList(filter = "") {
  const words = Object.keys(dictionary || {}).sort();
  wordListEl.innerHTML = "";

  words
    .filter(w => w.toLowerCase().includes(filter.toLowerCase()))
    .forEach(word => {
      const item = document.createElement("div");
      item.className = "word-item" + (word === currentWord ? " active" : "");
      item.textContent = word;
      item.onclick = () => selectWord(word);
      wordListEl.appendChild(item);
    });

  wordCountBadgeEl.textContent = words.length + " words";
}

/* SELECT WORD */
function selectWord(word) {
  currentWord = word;
  currentWordEl.textContent = word;

  const entry = dictionary[word];
  if (!entry) {
    scalesContainerEl.innerHTML = "";
    return;
  }

  semanticInput.value = entry.semantic_field || "";
  wordInput.value = word;

  renderScales(entry);
  renderWordList(searchInputEl.value);
}

/* RENDER SCALES WITH ADD+ */
function renderScales(entry) {
  scalesContainerEl.innerHTML = "";
  const order = ["mild", "medium", "strong", "extreme"];

  order.forEach(level => {
    const synonyms = entry.scales[level] || [];
    const row = document.createElement("div");
    row.className = "scale-row";

    const label = document.createElement("div");
    label.className = "scale-label";

    const left = document.createElement("div");
    left.className = "scale-label-left";
    left.innerHTML = `<span>${level.toUpperCase()}</span><span style="font-size:11px;color:#6b7280;">${synonyms.length} items</span>`;

    const addBtn = document.createElement("button");
    addBtn.className = "scale-add-btn";
    addBtn.textContent = "Add +";
    addBtn.onclick = () => {
      if (!currentWord) return;
      const newSyn = prompt('Add synonym to "' + currentWord + '" [' + level.toUpperCase() + ']');
      if (!newSyn) return;
      entry.scales[level].push(newSyn.trim());
      syncToProject();
      selectWord(currentWord);
    };

    label.appendChild(left);
    label.appendChild(addBtn);
    row.appendChild(label);

    const chips = document.createElement("div");
    chips.className = "synonym-chips";

    synonyms.forEach((s, index) => {
      const chip = document.createElement("div");
      chip.className = "chip";
      chip.textContent = s;
      chip.title = "Click to remove";
      chip.onclick = () => {
        if (confirm('Remove "' + s + '" from ' + level.toUpperCase() + '?')) {
          synonyms.splice(index, 1);
          syncToProject();
          selectWord(currentWord);
        }
      };
      chips.appendChild(chip);
    });

    row.appendChild(chips);
    scalesContainerEl.appendChild(row);
  });
}

/* MANUAL ADD SYNONYM */
addSynonymBtn.onclick = () => {
  const word = wordInput.value.trim();
  const sem = semanticInput.value.trim();
  const syn = synonymInput.value.trim();
  const level = intensitySelect.value;

  if (!word) return alert("Enter a word first.");
  if (!syn) return alert("Enter a synonym.");

  if (!dictionary[word]) {
    dictionary[word] = {
      semantic_field: sem || "",
      scales: { mild: [], medium: [], strong: [], extreme: [] }
    };
  }

  dictionary[word].scales[level].push(syn);
  synonymInput.value = "";
  syncToProject();
  renderWordList(searchInputEl.value);
  selectWord(word);
};

/* MANUAL SAVE WORD */
saveWordBtn.onclick = () => {
  const word = wordInput.value.trim();
  const sem = semanticInput.value.trim();

  if (!word) return alert("Word cannot be empty.");

  if (!dictionary[word]) {
    dictionary[word] = {
      semantic_field: sem,
      scales: { mild: [], medium: [], strong: [], extreme: [] }
    };
  } else {
    dictionary[word].semantic_field = sem;
  }

  syncToProject();
  renderWordList(searchInputEl.value);
  selectWord(word);
};

/* EDIT ALL SYNONYMS FOR CURRENT WORD */
editAllBtn.onclick = () => {
  if (!currentWord || !dictionary[currentWord]) {
    alert("Select a word first.");
    return;
  }
  const entry = dictionary[currentWord];

  const mildStr = (entry.scales.mild || []).join(", ");
  const mediumStr = (entry.scales.medium || []).join(", ");
  const strongStr = (entry.scales.strong || []).join(", ");
  const extremeStr = (entry.scales.extreme || []).join(", ");

  const mildNew = prompt(
    'Edit MILD synonyms for "' +
      currentWord +
      '" (comma-separated):',
    mildStr
  );
  if (mildNew === null) return;

  const mediumNew = prompt(
    'Edit MEDIUM synonyms for "' +
      currentWord +
      '" (comma-separated):',
    mediumStr
  );
  if (mediumNew === null) return;

  const strongNew = prompt(
    'Edit STRONG synonyms for "' +
      currentWord +
      '" (comma-separated):',
    strongStr
  );
  if (strongNew === null) return;

  const extremeNew = prompt(
    'Edit EXTREME synonyms for "' +
      currentWord +
      '" (comma-separated):',
    extremeStr
  );
  if (extremeNew === null) return;

  entry.scales.mild = mildNew
    .split(",")
    .map(s => s.trim())
    .filter(Boolean);
  entry.scales.medium = mediumNew
    .split(",")
    .map(s => s.trim())
    .filter(Boolean);
  entry.scales.strong = strongNew
    .split(",")
    .map(s => s.trim())
    .filter(Boolean);
  entry.scales.extreme = extremeNew
    .split(",")
    .map(s => s.trim())
    .filter(Boolean);

  syncToProject();
  renderWordList(searchInputEl.value);
  selectWord(currentWord);
};

/* EXPORT DICTIONARY (CURRENT PROJECT) */
exportBtn.onclick = () => {
  const proj = getActiveProject();
  const blob = new Blob([JSON.stringify(proj.dictionary, null, 2)], {
    type: "application/json"
  });
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = url;
  a.download = (proj.name || "semantic_dictionary") + ".json";
  a.click();
};

/* IMPORT DICTIONARY (LOAD PROJECT INTO NEW TAB) */
importFile.onchange = e => {
  const file = e.target.files[0];
  if (!file) return;

  const reader = new FileReader();
  reader.onload = evt => {
    try {
      const dict = JSON.parse(evt.target.result);
      const name = file.name.replace(/\.json$/i, "");
      const p = createEmptyProject(name);
      p.dictionary = dict;
      projects.push(p);
      activeProjectId = p.id;
      saveProjects();
      setActiveProject(activeProjectId);
    } catch {
      alert("Invalid JSON file.");
    }
  };
  reader.readAsText(file);
};

/* TOPBAR: NEW / LOAD / SAVE AS */
newProjectBtn.onclick = () => {
  const name = prompt("New project name:", "New Project");
  const p = createEmptyProject(name || "New Project");
  projects.push(p);
  activeProjectId = p.id;
  saveProjects();
  setActiveProject(activeProjectId);
};

loadProjectBtn.onclick = () => {
  importFile.click();
};

saveAsBtn.onclick = () => {
  const proj = getActiveProject();
  const name = prompt("Save As — project name / file name (without .json):", proj.name || "");
  if (!name) return;
  proj.name = name.trim();
  projectName = proj.name;
  updateProjectNameLabel();
  saveProjects();
  const blob = new Blob([JSON.stringify(proj.dictionary, null, 2)], {
    type: "application/json"
  });
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = url;
  a.download = proj.name + ".json";
  a.click();
};

/* SEARCH */
searchInputEl.oninput = () => {
  renderWordList(searchInputEl.value);
};

/* PILOT MODE — AUTO WORD BUILDER (CURRENT PROJECT) */
pilotBtn.onclick = async () => {
  const proj = getActiveProject();
  if (!proj) return;

  const word = prompt("Pilot: What word do you want to add or update?");
  if (!word) return;

  const cleanWord = word.trim().toLowerCase();
  if (!cleanWord) return;

  let semanticField = "";
  if (dictionary[cleanWord] && dictionary[cleanWord].semantic_field) {
    const keep = confirm(
      'Existing semantic field: "' +
        dictionary[cleanWord].semantic_field +
        '".\n\nOK = keep, Cancel = set new.'
    );
    if (keep) {
      semanticField = dictionary[cleanWord].semantic_field;
    } else {
      semanticField =
        prompt(
          'Pilot: Semantic field for "' +
            cleanWord +
            '"?\n(e.g., power / momentum / determination)'
        ) || "";
    }
  } else {
    semanticField =
      prompt(
        'Pilot: Semantic field for "' +
          cleanWord +
          '"?\n(e.g., power / momentum / determination)'
      ) || "";
  }

  if (!confirm('Pilot: Fetch synonyms for "' + cleanWord + '" now?')) return;

  try {
    const response = await fetch(
      "https://api.datamuse.com/words?rel_syn=" + encodeURIComponent(cleanWord)
    );
    const data = await response.json();

    if (!Array.isArray(data) || data.length === 0) {
      alert("Pilot: No synonyms found from the service.");
      return;
    }

    const rawSyns = data.map(d => d.word).filter(Boolean);

    const preview = rawSyns.slice(0, 30).join(", ");
    const proceed = confirm(
      'Pilot: Synonyms for "' +
        cleanWord +
        '" (up to 30 shown):\n\n' +
        preview +
        "\n\nOK = use them, Cancel = abort."
    );
    if (!proceed) return;

    const mild = [];
    const medium = [];
    const strong = [];
    const extreme = [];

    rawSyns.forEach((s, index) => {
      const pos = index / rawSyns.length;
      if (pos < 0.25) mild.push(s);
      else if (pos < 0.5) medium.push(s);
      else if (pos < 0.75) strong.push(s);
      else extreme.push(s);
    });

    const summary =
      'Pilot: Proposed intensity bands for "' +
      cleanWord +
      '"\n\n' +
      "MILD (" +
      mild.length +
      "): " +
      mild.slice(0, 10).join(", ") +
      (mild.length > 10 ? "..." : "") +
      "\n\nMEDIUM (" +
      medium.length +
      "): " +
      medium.slice(0, 10).join(", ") +
      (medium.length > 10 ? "..." : "") +
      "\n\nSTRONG (" +
      strong.length +
      "): " +
      strong.slice(0, 10).join(", ") +
      (strong.length > 10 ? "..." : "") +
      "\n\nEXTREME (" +
      extreme.length +
      "): " +
      extreme.slice(0, 10).join(", ") +
      (extreme.length > 10 ? "..." : "") +
      "\n\nOK = accept & save, Cancel = abort.";

    const accept = confirm(summary);
    if (!accept) return;

    if (!dictionary[cleanWord]) {
      dictionary[cleanWord] = {
        semantic_field: semanticField,
        scales: { mild: [], medium: [], strong: [], extreme: [] }
      };
    }

    dictionary[cleanWord].semantic_field = semanticField;
    dictionary[cleanWord].scales.mild = mild;
    dictionary[cleanWord].scales.medium = medium;
    dictionary[cleanWord].scales.strong = strong;
    dictionary[cleanWord].scales.extreme = extreme;

    syncToProject();
    renderWordList(searchInputEl.value);
    selectWord(cleanWord);

    const again = confirm(
      'Pilot: "' +
        cleanWord +
        '" has been saved in project "' +
        proj.name +
        '".\n\nAdd another word now?'
    );
    if (again) {
      pilotBtn.onclick();
    }
  } catch (err) {
    console.error(err);
    alert("Pilot: Error fetching synonyms. Check your connection and try again.");
  }
};

/* INITIALIZE */
renderTabs();
syncFromProject();
</script>

</body>
</html>
